using UnityEngine;
using UnityEngine.Assertions;
using System.Collections;
using System.Collections.Generic;
using System;

public class PhaseInvulnerability : UntargetedAbilityConstraint {

    [SerializeField]
    protected float[] healthPercentageInvulnerabilities;

    PhaseTrigger[] phaseTriggers;

    Health targetHealth;
    Stackable targetStackable;
    Damageable[] targetDamageables;
    List<PhaseInvulnerability> otherPhaseInvulnerabilities = new List<PhaseInvulnerability>();

    bool invulnerable = false;
    int healthIndex = 0;

    protected override void Start() {
        base.Start();
        targetHealth = GetComponentInParent<Health>();
        targetStackable = GetComponentInParent<Stackable>();
        Assert.IsNotNull(targetHealth);
        Assert.IsNotNull(targetStackable);
        targetStackable.changeEvent += TargetStackable_changeEvent;
        phaseTriggers = transform.root.GetComponentsInChildren<PhaseTrigger>();
    }

    private void TargetStackable_changeEvent() {
        otherPhaseInvulnerabilities.Clear();
        foreach(Stackable stackable in targetStackable) {
            otherPhaseInvulnerabilities.AddRange(stackable.GetComponentsInChildren<PhaseInvulnerability>());
        }
    }

    public override bool Activate(PhotonStream stream) {
        Assert.IsFalse(invulnerable);
        invulnerable = true;
        targetDamageables = transform.root.GetComponentsInChildren<Damageable>();
        foreach (Damageable damageable in targetDamageables) {
            damageable.MagicalVulnerabilityMultiplier.AddModifier(0);
            damageable.PhysicalVulnerabilityMultiplier.AddModifier(0);
        }

        foreach (PhaseInvulnerability invulnerability in otherPhaseInvulnerabilities) {
            if (!invulnerability.invulnerable) {
                return true;
            }
        }
        //every part is invulnerable; trigger phase change

        //put everyone vulnerable again.
        foreach (PhaseInvulnerability invulnerability in otherPhaseInvulnerabilities) {
            invulnerability.Deactivate();
        }
        Assert.IsFalse(invulnerable);

        return true;
    }

    void Deactivate() {
        Assert.IsTrue(invulnerable);
        invulnerable = false;
        healthIndex++;

        foreach (Damageable damageable in targetDamageables) {
            damageable.MagicalVulnerabilityMultiplier.RemoveModifier(0);
            damageable.PhysicalVulnerabilityMultiplier.RemoveModifier(0);
        }

        //trigger other phase actions
        foreach (PhaseTrigger phaseTrigger in phaseTriggers) {
            phaseTrigger.Trigger(healthIndex);
        }
    }

    public override void Activate() { }

    public override bool isAbilityActivatible() {
        return !invulnerable && healthIndex < healthPercentageInvulnerabilities.Length && targetHealth.healthPercent <= healthPercentageInvulnerabilities[healthIndex];
    }
}
